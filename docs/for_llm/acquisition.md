# acquisition.py - 実装詳細

## 概要

マイコンのシリアルポートから ADC 済みの EOG（眼電図）信号をリアルタイムに取得し、プロジェクト内の複数箇所から参照できるようにする汎用モジュール。

## 設計要件と背景

### 要件

1. **汎用化**: プロジェクト内にはシリアルからの信号取得を行いリアルタイムに扱う箇所が複数存在する。それらに毎回取得方式を記述したくない
2. **共有データソース**: acquisition 側から他の処理を呼ぶのではなく、他の任意の処理から acquisition の取得する信号を監視して扱える形式にする
3. **設定の柔軟性**: acquisition モジュールは特定の設定ファイルに依存せず、呼び出し側が値を渡す

### 採用した設計とその理由

#### モジュールレベルのシングルトン

クラスインスタンスではなく、モジュール内部にグローバル状態を持つ。複数箇所から同じデータソースを参照するため、インスタンス管理の煩雑さを避けた。

#### 関数ベース API

`start()`, `stop()`, `get_latest()` などシンプルな関数で操作。クラスのインスタンス化やメソッド呼び出しより直感的。

#### コールバック不採用

当初コールバック登録方式を検討したが、以下の理由で不採用：

- 全登録処理がバックグラウンドスレッド内で同期的に発火する
- 重い処理を登録するとサンプリング（250Hz = 4ms 間隔）に影響
- 各処理が自分のタイミングで`get_latest()`を呼ぶ方式の方がシンプル

#### 設定値は引数で受け取る

`config.py`への依存を持たず、`start()`呼び出し時に設定値を渡す。呼び出し側が`config.py`を使うかどうかは自由。これによりモジュールの再利用性が向上。

## マイコン側の仕様

```
チャンネル数: 4 (ch1, ch2, ch3, ch4)
送信形式: CSV
  - ヘッダ行: "t_us,ch1,ch2,ch3,ch4"
  - データ行: "timestamp_us,ch1_value,ch2_value,ch3_value,ch4_value"
```

マイコン側のコードでは以下の設定：

- サンプリングレート: 250Hz（`constexpr uint32_t FS_HZ = 250`）
- ADC 解像度: 12bit（`analogReadResolution(12)`）
- ボーレート: 115200

## データ構造

```python
class AdcSample(NamedTuple):
    t_us: int       # マイコン側のタイムスタンプ (マイクロ秒)
    ch1: int        # チャンネル1の値
    ch2: int        # チャンネル2の値
    ch3: int        # チャンネル3の値
    ch4: int        # チャンネル4の値
    pc_time: float  # PC側の受信時刻 (time.time())
```

## 公開 API 一覧

| 関数                                             | 説明                                       |
| ------------------------------------------------ | ------------------------------------------ |
| `start(port, baudrate, adc_resolution, timeout)` | データ取得を開始。設定値は引数で渡す       |
| `stop()`                                         | データ取得を停止                           |
| `get_latest()`                                   | 最新のサンプルを取得（ノンブロッキング）   |
| `get_data(timeout)`                              | キューからデータを取得。timeout で待機可能 |
| `get_data_batch(max_count)`                      | 複数データを一括取得                       |
| `clear_queue()`                                  | キューをクリア                             |
| `is_running()`                                   | 取得中かどうか                             |
| `queue_size()`                                   | 現在のキューサイズ                         |
| `get_adc_resolution()`                           | 設定された ADC 解像度を取得                |
| `get_adc_max_value()`                            | 設定された ADC 最大値を取得                |
| `adc_to_voltage(adc_value, vref)`                | ADC 値を電圧に変換                         |

## 内部実装の詳細

### スレッド構成

- メインスレッド: `start()`/`stop()`の呼び出し、`get_latest()`等でのデータ取得
- バックグラウンドスレッド（daemon）: シリアルデータの継続的な読み取り

### データ格納

- `_latest_sample`: 最新のサンプルを保持（`get_latest()`用）
- `_data_queue`: 全データをキューに追加（`get_data()`用、最大 1000 件）
  - キューが満杯の場合は古いデータを破棄してローテーション

### スレッドセーフティ

- `_lock`: `_latest_sample`へのアクセスを保護
- `queue.Queue`: スレッドセーフなキュー実装を使用

### パース処理

- CSV ヘッダ行（`t_us,ch1,ch2`）は自動スキップ
- 不正な行（パース失敗）は無視して継続

## 依存関係

- `pyserial`: シリアル通信

## config.py との関係

このモジュールは`config.py`に依存しない。呼び出し側が`config.py`を使用するかは自由。

`config.py`を使う場合の推奨設定例：

```python
# config.py
PORT = "/dev/cu.usbmodem103"
BAUDRATE = 115200
SAMPLING_RATE_HZ = 250
ADC_RESOLUTION = 12
```

## 使用上の注意

- `start()`は一度だけ呼ぶこと（二重呼び出しは無視される）
- サンプリングレート（250Hz = 4ms 間隔）以上の頻度で`get_latest()`を呼ばないとサンプルを飛ばす可能性がある
- データを漏れなく処理したい場合は`get_data()`または`get_data_batch()`を使用

## 改修時の注意

- バックグラウンドスレッドは daemon スレッドなので、メインプログラム終了時に自動終了
- `_read_loop()`内でのエラーは極力継続（`SerialException`のみ break）
- ADC 解像度は`start()`時に設定され、以降変更不可
